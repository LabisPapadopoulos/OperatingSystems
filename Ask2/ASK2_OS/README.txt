						README - Άσκηση 2 OS (2012 - 2013)
						     Χαράλαμπος Παπαδόπουλος
							ΑΜ: 1115200800169

=== semaphore.c ===
semaphore_init():
-----------------
Δεσμεύει ένα σετ των 3ων σημαφόρων από το σύστημα δημιοθργώντας το αν δεν υπάρχει και επιστρέφει 0 ή -1 σε περίπτωση σφάλματος.

semaphore_finalize():
---------------------
Αποδεσμεύει το σετ των σημαφόρων και επιστρέφει 0 ή -1 σε περίπτωση σφάλματος.

semaphore_up(unsigned short int sem): 
-------------------------------------
Ανεβάζει ένα σημαφόρο. Παίρνει σαν όρισμα το αναγνωριστικό του σημαφόρου και επιστρέφει 0 ή -1 σε περίπτωση σφάλματος.

semaphore_down(unsigned short int sem): 
---------------------------------------
Κατεβάζει ένα σημαφόρο. Παίρνει σαν όρισμα το αναγνωριστικό του σημαφόρου και επιστρέφει 0 ή -1 σε περίπτωση σφάλματος.

=== shmem.c ===
memory_init(): 
---------------
Δεσμεύει ένα τμήμα κοινής μνήμης για τα σήματα VP_START, VP_STOP, MANAGER_STOP και ένα τμήμα για μια Process. Το μέγεθος της μνήμης που δεσμεύεται είναι ένας χαρακτήρας (sizeof(char)) και μια δομή (sizeof(process_t)) για την αποστολή του σήματος (VP_START ή VP_STOP ή MANAGER_STOP) και της διεργασίας στον Manager δηλαδή (sizeof(char) + sizeof(process_t)). Η διεύθυνση και το αναγνωριστικό της μνήμης αποθηκεύονται σε global μεταβλητές. Επιστρέφει 0 ή -1 σε περίπτωση σφάλματος.

memory_finalize():
-------------------
Αποδεσμεύει την κοινή μνήμη που είχε δεσμευτεί με την memory_init(). Επιστρέφει 0 ή -1 σε περίπτωση σφάλματος.

read_message(char *flag, process_t *process):
---------------------------------------------
Διαβάζει ένα εισερχόμενο μήνυμα από την κοινή μνήμη που είχε δεσμευτεί από την memory_init(). Δέχεται ως ορίσματα ένα δείκτη σε flag και ένα δείκτη σε δομή process στους οποίους θα αποθηκεύσει το σήμα (VP_START ή VP_STOP ή MANAGER_STOP) και την διεργασία που στέλνει ο Generator στον Manager.

write_message(char flag, process_t process):
--------------------------------------------
Γράφει ένα εισερχόμενο μήνυμα στην κοινή μνήμη που είχε δεσμευτεί από την memory_init(). Δέχεται ως ορίσματα το flag και την process που στέλνει ο Generator στον Manager.

=== generator.c ===
generator(unsigned int D, unsigned int t, unsigned int T, unsigned int lo, unsigned int hi):
--------------------------------------------------------------------------------------------
Παίρνει ως ορίσματα την διάρκεια προσομείωσης (D), τον μέσο χρόνο μεταξύ δυο διαφορετικών διεργασιών (t), τον μέσο χρόνο ζωής της διεργασίας (T), το κάτω όριο για μνήμη διεργασίας (lo) και το πάνω όριο για μνήμη διεργασίας (hi).
O Generator γεννά διεργασίες VP (Virtual Processes) τις οποίες τις αρχικοποιεί σύμφωνα με τις τιμές των παραμέτρων, κατεβάζει το σημαφόρο της διαμοιραζόμενης μνήμης (MEMORY) για να εξασφαλίσει την αποκλειστική πρόσβαση σε αυτή, γράφει τη διεργασία μαζί μ' ένα μήνημα VP_START (flag) και ανεβάζει τον σημαφόρο MESSAGE για να ειδοποιήσει τον manager (που παρέμενε κολλημένος προσπαθώντας να κατεβάσει τον σημαφόρο MESSAGE) να διαβάσει την μνήμη. Στη συνέχεια για κάθε διεργασία που γράφεται μέσα στη μνήμη δημιουργείται ένα νέο thread το οποίο μετά από κάποια διάρκεια ύπνου κατεβάζει τον σημαφόρο της μνήμης, γράφει σήμα VP_STOP μαζί με την διεργασία που είχε δημιουργηθεί και ανεβάζει τον σημαφόρο MESSAGE για να ειδοποιήσει τον manager για να διαβάσει το μήνυμα και να σταματήσει την διεργασία (χρήση συνάρτησης: void* stopper(void* process)).
Οι νέες διεργασίες που τοποθετούνται στη μνήμη προκύπτουν σύμφωνα με την κατανομή Poisson (οι χρόνοι μεταξύ δυο διαδοχικών αφίξεων είναι ανεξάρτητοι μεταξύ τους και εκθετικά καταναμημένοι με μέση διάρκεια τ). Μόλις τελειώσει η διάρκεια προσωμείωσης (D), μαζεύονται όλα τα νήματα (join) που είχαν ανοιχτεί προηγουμένως και ειδοποιεί τον manager για να σταματήσει να εκτελείται (κατεβάζοντας τον σημαφόρο της μνήμης MEMORY, γράφοντας το stop flag και ανεβάζοντας τον σημαφόρο MESSAGE ωστε να ξεμπλοκαριστεί ο manager).

=== manager.c ===
manager(unsigned int S, unsigned int D, int algorithm):
-------------------------------------------------------
Παίρνει ως όρισμα το μέγεθος μνήμης (S), την διάρκεια προσομείωσης (D) και το είδος του αλγορίθμου που θα χρησιμοποιήσει (best-fit, worst-fit και buddy). Αρχικά αρχικοποιεί την δομή της μνήμης που θα χρησιμοποιηθεί στην προσομείoση, ανοίγει ενα αρχείο που θα γράφει log μηνύματα, επιλέγει ποιον αλγόριθμο θα χρησιμοποιήσει και στη συνέχεια μόλις γίνει με επιτυχία το κατέβασμα του σημαφόρου MESSAGE (ο οποίος θα είχε ανέβει απο τον generator ως τρόπο ειδοποίησης του manager) διαβάζει την διαμοιραζόμεη μνήμη αποθηκεύοντας την διεργασία και το flag (VP_START ή VP_STOP ή MANAGER_STOP) και ανεβάζει τον σημαφόρο της μνήμης για να μπορεί να γράψει ο generator νέο μήνυμα σ' αυτή. Στη συνέχεια πράτει σύμφωνα με το flag που διάβασε. Συγκεκριμένα σε περίπτωση που διάβασε MANAGER_STOP, γράφει στο log αρχείο που είχε ανοίξει πιο πριν τα στατιστικά στοιχεία και τις μετρικές απόδoσης κάθε τεχνικής και μετά κλείνει το αρχείο. 
Στην περίπτωση VP_START, ο manager κατεβάζει τον σημαφόρο PROCESSES για να εξασφαλίσει τον αμοιβαίο αποκλεισμό στην μνήμη και στην ουρά αναμονής, προσθέτει την διεργασία στην μνήμη. Αν η διεργασία μπει στην μνήμη με επιτυχία, δημιουργείται δυναμικά μια συνδεδεμένη λίστα (empty_list) για τον υπολογισμό των στατιστικών και ανεβάζει τον σημαφόρο PROCESSES. Αν η διεργασία δεν χωράει να μπει στη μνήμη, τότε προστίθεται σε μια λίστα αναμονής και μετα ανεβάζει τον σημαφόρο PROCESSES, ενώ αν συμβέι σφάλμα κατά την προσθήκη της διεργασίας τοτε απλά ανεβάζει τον σημαφόρο PROCESSES.
Στην περίπτωση VP_STOP, ο manager δημιουργεί νήμα για κάθε διεργασία για να την διαγράψει μετά απο συγκεκριμένη παράταση με χρήση της συνάρτησης: void* paratash(void* process). Μέσα σ' αυτή αρχικά κατεβάζει τον σημαφόρο PROCESSES για να υπάρχει συγχρονισμός στην διαγραφή και αφού την διαγράψει προσθέτει ένα κόμβο στη λίστα για τον υπολογισμό των στατιτικών (empty_list) και εξετάζει αν το κενό που δημιουργήθηκε μπορεί να καλυφθεί από άλλη process που βρίσκεται στην ουρά αναμονής L.

best_fit_add(process_t process):
--------------------------------
Εισάγει μια διεργασία στη μνήμη σύμφωνα με τον αλγόριθμο best-fit.
Παίρνει σαν όρισμα μια process και επιστρέφει -1 σε περίπτωση σφάλματος, 0 αν δεν υπάρχει κατάλληλος χώρος για να τοποθετηθεί η διεργασία και 1, αν τοποθετήθηκε με επιτυχία στη μνήμη. Συγκεκριμένα σαρώνει σειριακά την λίστα της μνήμης ψάχνοντας το μικρότερο κομμάτι μνήμης που χωράει την διεργασία. Αν το κομμάτι που βρεθεί είναι μεγαλύτερο απο την διεργασία, κρατάει μόνο όση μνήμη χρειάζεται και την υπόλοιπη την αφήνει κενή.

worst_fit_add(process_t process):
---------------------------------
Εισάγει μια διεργασία στη μνήμη σύμφωνα με τον αλγόριθμο worst-fit.
Παίρνει σαν όρισμα μια process και επιστρέφει -1 σε περίπτωση σφάλματος, 0 αν δεν υπάρχει κατάλληλος χώρος για να τοποθετηθεί η διεργασία και 1, αν τοποθετήθηκε με επιτυχία στη μνήμη. Συγκεκριμένα σαρώνει σειριακά την λίστα της μνήμης ψάχνοντας το μεγαλύτερο κομμάτι μνήμης που χωράει την διεργασία. Αν το κομμάτι που βρεθεί είναι μεγαλύτερο απο την διεργασία, κρατάει μόνο όση μνήμη χρειάζεται και την υπόλοιπη την αφήνει κενή.

best_worst_fit_remove(process_t process):
-----------------------------------------
Διαγράφει μια process απο την μνήμη σύμφωνα με τον αλγόριθμο best-fit ή worst-fit (είναι κοινή και για τους δυο αλγορίθμους).
Παίρνει σαν όρισμα μια process και επιστρέφει -1 σε περίπτωση σφάλματος, 0 αν δεν εχει βρει το segment προς αδειασμα και 1, αν διαγράφτηκε με επιτυχία η process. Συγκεκριμένα σαρώνει σειριακά όλη την λίστα της μνήμης ψάχνοντας την συγκεκριμένη process, αν την βρει αδειάζει το συγκεκριμένο κομμάτι μνήμης που την περιέχει και το συνενώνει με τυχόν γειτονικά κομμάτια μνήμης που επίσης είναι άδεια.

buddy_add(process_t process):
-----------------------------
Εισάγει μια process στην μνήμη σύμφωνα με τον αλγόριθμο buddy.
Παίρνει σαν όρισμα μια process και επιστρέφει -1 σε περίπτωση σφάλματος, 0 αν δεν υπάρχει κατάλληλος χώρος για να τοποθετηθεί η διεργασία και 1, αν τοποθετήθηκε με επιτυχία στη μνήμη. Συγκεκριμένα σαρώνει σειριακά όλη τη λίστα της μνήμης καλώντας την αναδρομική συνάρτηση buddy_add_recursion για κάθε κομμάτι μνήμης που συναντάει.

buddy_add_recursion(process_t process, memory_segment_t *segment):
------------------------------------------------------------------
Εισάγει μια process σ' ένα κομμάτι μνήμης αναδρομικά σύμφωνα με τον αλγόριθμο buddy.
Παίρνει σαν όρισμα μια process και ένα δείκτη σε memory_segment_t και επιστρέφει -1 σε περίπτωση σφάλματος, 0 αν δεν υπάρχει κατάλληλος χώρος για να τοποθετηθεί η διεργασία και 1, αν τοποθετήθηκε με επιτυχία στη μνήμη. Συγκεκριμένα προσπαθεί να εισάγει την process στο κομμάτι μνήμης segment ή αναδρομικά σε κάποιο από τα παιδιά του. Άν η διεργασία χωράει σε κάποιο απο τα παιδιά τότε εισάγεται αναδρομικά εκεί, αλλιώς εισάγεται στον τρέχον κόμβο.

buddy_remove(process_t process):
--------------------------------
Διαγράφει μια process απο την μνήμη σύμφωνα με τον αλγόριθμο buddy.
Παίρνει σαν όρισμα μια process και επιστρέφει -1 σε περίπτωση σφάλματος, 0 αν δεν εχει βρει το process προς διαγραφή και 1, αν διαγράφτηκε με επιτυχία η process. Συγκεκριμένα καλεί την αναδρομική με ορίσματα την process και όρια από 0 μέχρι το μέγεθος της μνήμης (S), δηλαδή ψάχνει όλη τη διαθέσιμη μνήμη.

buddy_remove_recursion(process_t process, unsigned int start, unsigned int end):
--------------------------------------------------------------------------------
Διαγράφει αναδρομικά μια process από ένα τμήμα της μνήμης σύμφωνα με τον αλγόριθμο buddy.
Παίρνει σαν όρισμα μια process και τα όρια του τμήματος της μνήμης και επιστρέφει -1 σε περίπτωση σφάλματος, 0 αν δεν εχει βρει το process προς διαγραφή και 1, αν διαγράφτηκε με επιτυχία η process. Συγκεκριμένα σαρώνει σειριακά όλη τη λίστα της μνήμης ψάχνοντας ένα τμήμα που να ξεκινάει από το start και να τελειώνει στο end. Αν βρει ένα τέτοιο τμήμα το αδειάζει αν περιέχει την διεργασία και επιστρέφει. Διαφορετικά το διαιρεί στα δυο και ψάχνει αναδρομικά στα παιδιά του. Στο τέλος της αναδρομής αν και τα δυο παιδιά είναι κενά ενώνονται σ' ένα κόμβο.

add_wait_list(process_t process):
---------------------------------
Κάνει εισαγωγή μιας process στο τέλος της λίστας αναμονής L.
Παίρνει σαν όρισμα μια process και επιστρέφει 0 ή -1 σε περίπτωση σφάλματος.

swap_list_to_memory(time_t now):
--------------------------------
Ψάχνει τη λίστα αναμονής για διεργασίες που χωράνε στη μνήμη και τις εισάγει.
Παίρνει ως είσοδο την τρέχουσα χρονική στιγμή (now) σε seconds και επιστρέφει -1 σε πείπτωση σφάλματος, 0 αν δεν υπάρχει καμία διεργασία που να χωράει στη μνήμη και 1 αν υπήρχαν διεργασίες που μπήκαν στη μνήμη και αφαιρέθηκαν με επιτυχία από τη λίστα αναμονής. Η λίστα σαρώνεται σειριακά και στην περίπτωση που βρεθεί μια διεργασία να χωράει στη μνήμη καλεί πάλι τον εαυτό της αναδρομικά επειδή μπορεί να υπάρχει και άλλη διεργασία που να χωράει στη μνήμη.

empty_memory(void):
-------------------
Επιστρέφει τον άδειο χώρο της μνήμης (συνολική χωρητικότητα μνήμης - συνολική χωρητικότητα διεργασιών).
Χρησιμοποιείται για τα στατιστικά.

show_memory(void):
------------------
Εμφανίζει ένα χάρτη μνήμης που δείχνει τα χαρακτηριστικά των process που υπάρχουν εκείνη τη στιγμή στη μνήμη.

show_wait_list(void):
---------------------
Εμφανίζει την λίστα αναμονής που δείχνει τα χαρακτηριστικά των process που υπάρχουν εκείνη τη στιγμή στη λίστα.

=== main.c ===
main(int argc, char** argv):
----------------------------
Διαβάζει τα ορίσματα απο τη γραμμή εντολών και αρχικοποιεί την κοινή μνήμη και τους σημαφόρους.
Στη συνέχεια δημιουργεί μια ακόμα διεργασία η οποία θα τρέξει τον generator ενώ η αρχική διεργασία θα τρέξει τον manager. Όταν και οι δυο δεργασίες τερματίσουν καθαρίζει την κοινή μνήμη και τους σημαφόρους.

Συμπεράσματα από τις εκτελέσεις:
Γενικά παρατηρούμε οτι ο worst-fit τα πάει καλά με τις μικρές διεργασίες γιατί πάντα προτιμάει το μεγαλύτερο κενό για την εισαγωγή διεργασιών και έτσι καταλήγει να αφήνει πολλά μικρά κενά τμήματα (έχει μεγάλο εξωτερικό κατακερματισμό).
Αντίθετα ο best-fit τα πάει καλά με τις μεγάλες διεργασίες (δεδομένου οτι χωράνε) γιατί προτιμάει το μικρότερο κενό για την εισαγωγή τους και έτσι συνήθως καταλήγει να έχει σχετικά λίγα αλλά μεγαλύτερα κενά τμήματα (προσπαθεί να μειώσει το εξωτερικό κατακερματισμό όσο μπορεί).
Τέλος ο buddy είναι σχετικά μέτριος τόσο με μικρές όσο και με μεγάλες διεργασίες επειδή η διαμέριση του χώρου που κάνει του εξασφαλίζει οτι θα υπάρχουν και μικρά και μεγάλα κομμάτια διαθέσιμα. Επειδή όμως μπορεί να αφιερώσει σε μια διεργασία παραπάνω χώρο απ' όσο πραγματικά χρειάζεται έχει μεγάλο εσωτερικό κατακερματισμό.

Compile: gcc -ansi -Wall *.c -o askish2 -lpthread -lm
Run: ./askish2 -D 10 -t 1 -T 3 -lo 2 -hi 3 -S 20 -alg 1

